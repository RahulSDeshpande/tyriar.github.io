---
layout      : post
title       : Given random5(), implement random7()
tags        : [Algorithm, Computer science, Interview questions, Java, Math]
draft : 1
preview     : /images/2014/03/02/function.svg
socialimage : /images/2014/03/02/function.png
primarytag  : Interview questions
intro       : Given the function <code>random5</code> that generates and returns a random integer from 1 to 5, implement <code>random7</code> that returns a uniformly distributed random integer from 1 to 7.
---

{% include post-image.html class="right-col" alt="Given random5 function input and 1 to 7 output, implement random7" src="/images/2014/03/02/function.png" %}

This is a classic probability problem that turns out to be deceptively tricky since solutions that seem fine don't end up filling the uniformly distributed requirement.

## Analysis

To start off, let's reread what we're supposed to do:

> implement `random7` that returns a ***uniformly distributed*** random ***integer*** from 1 to 7.

We're dealing with *integers* not floats, so it's not as simple as multiplying `random5` by `7/5`. It also needs to be *uniformly distributed* just like `random5`, meaning we cannot just return the result of `random5() * 2 % 7 + 1` since that will favour the integers 2, 3 and 4 twice as much as the rest.

How about this then?

    (random5() + random5() + random5() + random5() + random5() + random5() + random5()) % 7 + 1

This turns out to be a very common answer to the problem, but does each number have an equal chance of being generated?

`random5` gives a \\(20\%\\) chance to get each of the numbers from 1 to 5. If we add `random5` 7 times then to get the value 7, we need to 'roll' 1 on every `random5` which would be \\(0.2^{7} = 0.00128\%\\) chance, which is also the chance of any particular permutation of rolls occurring.

Whereas the value 8 could be generated by rolling 1 on 6 of the calls to `random5` and 2 on the other one, giving up a possible 7 different permutations that could occur and therefore a \\(0.2^{7} \cdot 7 = 0.00896\%\\) chance of occurring.

| Value    | Possible permutations | Chance
|----------|-----------------------|-------
| 7        | 1                     | 0.00128%
| 8        | 7                     | 0.00896%
| 9        | 28                    | 0.03584%
| &hellip; | &hellip;              | &hellip;
| 33       | 28                    | 0.03584%
| 34       | 7                     | 0.00896%
| 35       | 1                     | 0.00128%

So this function will actually favour numbers in the middle more than the outer values.

<hr>

A good solution to the problem would be to look at it like a decision tree. Calling `random5` once to get 5 choices (\\(20\%\\) chance each) that are then split up into another 5 choices (\\(4\%\\) chance each). Giving 25 choices in total, each of which map to a particular action.

| Choice number | Action
|---------------|-------
| 1-21          | Return `choice number % 7 + 1`
| 22-25         | Return `random7()`

With this solution, in a single call each number has a \\(12\%\\) chance of returning and there is a \\(16\%\\) chance that `random7()` will be called again recursively and returned.



## Code

[View on GitHub][1]

<!--prettify lang=java-->
    public static int random7() {
        int val = random5() * 5 + random5();
        return val > 21 ? random7() : val % 7 + 1;
    }



[1]: https://github.com/Tyriar/growing-with-the-web/tree/master/algorithms/interview-questions/given-random5-implement-random7